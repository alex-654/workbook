### Варианты повышения производительности и скорости бэкэнда

- Не блокирующий I/O
- Обработка одного запроса несколькими ядрами/потоками

#### Отдельные процессы

fastCgi -> php

#### Нити операционной системы

ОС может породить больше нитей чем процессов т.к. они более легковесны
MySQL запускает один процесс и дальше все запросы обрабатывает в отдельных тредах
Проблема доступа к общей памяти, накладывание локов и синхронизация данных.

#### Кооперативная многозадачность

С точки зрения ОС кооперативная многозадачность – это просто один поток выполнения, но внутри него само приложение
переключается между обработкой отдельных запросов. Как только пришли какие-то данные, я их прочитал, разобрал
http-запрос, подумал, что мне надо сделать, отправил запрос memcached, а это блокирующаяся операция, я буду ждать, пока
придет ответ от memcached, и вместо того, чтобы ждать, я начинаю обрабатывать другой запрос.

Недостаток кооперативной многозадачности в том, что такая программа может использовать только одно ядро процессора.
Хорошо бы сделать так, чтоб мы запустили несколько процессов или несколько нитей и внутри каждого процесса или нити
использовали кооперативную многозадачность.

2 классических примера – это nginx, в котором вы настраиваете количество воркеров, имеет смысл увеличивать количество
воркеров до числа ядер в вашей системе, это отдельные процессы. Внутри воркера каждый воркер использует неблокирующийся
ввод-вывод и кооперативную многозадачность, чтобы обслужить большое количество одновременных соединений. Воркеры нужны
только для того, чтобы распараллелиться между отдельными процессорами.

Второй пример – это memcached, который я уже приводил. У него есть опция запуститься на несколько потоков, несколько
нитей ОС. Тогда у нас запускается несколько нитей, внутри каждой из них крутится реактор, обеспечивающий неблокирующийся
ввод-вывод и кооперативную многозадачность, а несколько потоков позволяют использовать эффективно несколько ядер
процессора. Ну, а общей памятью memcached является ведь кэш, который собственно он и обслуживает. Все эти потоки читают
и пишут из того же самого кэша

#### Примеры

Есть Java со своей виртуальной машиной и все, соответственно, языки которые работают на JVM, потоки ОС уже давно,
когда-то тоже в самом начале были грин треды. Есть возможность делать блокирующий и неблокирующий ввод-вывод, и как в
любом мире enterprise есть какой-нибудь framework, который я могу воткнуть в середину, и он для меня вообще все это дело
абстрагирует. Мне все равно, я ему просто сказал, что делать, а моя задача – только писать что то сверху.

Есть Go, который появился относительно недавно, поэтому смог уже на старте оторваться от преследователей и сделать сразу
что-то интересное. В Go есть горутины, которые являются по сути своей грин тредами, т.е. не являются потоками ОС, но с
другой стороны внутренний механизм выполнения основан на том, что может быть запущено несколько потоков ОС, на которые
будут шедулиться горутины, т.е. это комбинация кооперативной многозадачности и многопоточности. Внутри "под капотом"
всегда неблокирующийся ввод-вывод. Из моей горутины я делаю операции, как будто бы они блокирующиеся, но на самом деле
происходит переключение между горутинами, как только я заблокировался, будет выполняться другая горутина. В Go много
всего еще интересного, там есть каналы, своя концепция конкурентного программирования.